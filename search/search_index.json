{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Para esta tarea se usaron tres distintos m\u00e9todos para trabajar con ecuaciones diferenciales no lineales.</p> <p>1) M\u00e9todo de Euler </p> <p>El m\u00e9todo de Euler se basa en una expansi\u00f3n de Taylor de la funci\u00f3n de x(t). Por ser un m\u00e9todo simple, su aproximaci\u00f3n es menos precisa en comparaci\u00f3n a los otros m\u00e9todos utilizados. Para iniciar este m\u00e9todo se debe encontrar el n\u00famero de pasos que vamos a considerar. Mediante la siguiente ecuaci\u00f3n: </p> <p> </p> <p>N siendo el n\u00famero de pasos, tf tiempo final y t0 tiempo inicial. Luego para hacer las iteraciones el valor de x me var\u00eda de la forma:  </p> <p>Y t var\u00eda de la forma:   </p> <p>2) M\u00e9todo de Runge-Kutta 2do Orden (RK2) Este m\u00e9todo tambi\u00e9n es llamado punto medio, ya que se basa en este principio matem\u00e1tico. Se inicia con las siguientes dos ecuaciones:   </p> <p>Luego con estos valores encontrados, podemos actualizar los valores de x y t, con las siguientes ecuaciones:   </p> <p>Y este proceso se repite de manera iterativa, hasta llegar al tiempo final deseado. </p> <p>3) M\u00e9todo de Runge-Kutta 4to Orden (RK4)</p> <p>Por \u00faltimo se trabaja con este m\u00e9todo, que sigue la misma idea de RK2. La diferencia es que se trabajan con m\u00e1s ecuaciones de k, mostradas a continuaci\u00f3n:   </p> <p>Luego se actualizan los valores de x, t, con:   </p> <p>De los tres m\u00e9todos utilizados en este proyecto, este es el que mejores valores aproximados genera.</p>"},{"location":"about.html","title":"About","text":"<p>Stephanie Chaves Hern\u00e1ndez - B92158</p> <p>Mar\u00eda Jos\u00e9 Ram\u00edrez Rivera - B96394</p> <p>Isaac Jos\u00e9 Prado Berm\u00fadez - B96093</p>"},{"location":"reference.html","title":"Reference","text":"<pre><code>\nEste c\u00f3digo implementa el m\u00e9todo de Euler para resolver una ecuaci\u00f3n diferencial \nordinaria (EDO)\n#Euler Gr\u00e1ficos\nImportaci\u00f3n de bibliotecas\nimport numpy as np\nimport matplotlib.pyplot as plt \n\nDefinici\u00f3n de la EDO a resolver\ndef f(x,t):\n    return -x**3+np.sin(t)\n\n\nPar\u00e1metros iniciales, brindados por el enunciado \nt0=0\nx0=0\ntf=10\n\nEn esta funci\u00f3n se da la implementaci\u00f3n del m\u00e9todo de Euler. Primero se calcula\n el n\u00famero de pasos,siendo esta una funci\u00f3n que depende de los tiempos inicial\n y final, as\u00ed mismo de la h (dato dado en el enunciado). Luego se inicializan \n los arrays de t y x, con ceros, y se establecen las condiciones iniciales. \n Siguiendo con el bucle for, que es el encargado de generarme las iteraciones \n con las actualizaciones de t y x en cada paso, utilizando el m\u00e9todo de Euler. \n Finalmente, se devuelven los arrays con los valores finales de t y x. \n\ndef euler(f, t0, x0, tf, h):\n    n_steps=int((tf-t0)/h)\n    t=np.zeros(n_steps+1)\n    x=np.zeros(n_steps+1)\n\n    t[0]=t0\n    x[0]=x0\n\n    for n in range(n_steps):\n        t[n+1]=t[n]+h\n        x[n+1]=x[n]+h*f(x[n], t[n])\n    return t, x\n\nAqu\u00ed simplemente se evaluaron dos distintos h, primero h= 20 y luego h=1000\n#20 pasos \nh_20=(tf-t0)/20\nt_20, x_20 = euler(f, t0, x0, tf, h_20)\n\n#1000 pasos \nh_1000=(tf-t0)/1000\nt_1000, x_1000 = euler(f, t0, x0, tf, h_1000)\n\nY por \u00faltimo se crea un gr\u00e1fico para visualizar las soluciones de la EDO obtenidas \ncon 20 y 1000 pasos\n\nplt.figure(figsize=(10, 6))\nplt.plot(t_20, x_20, label='20 pasos', marker='o')\nplt.plot(t_1000, x_1000, label='1000 pasos', linestyle='--')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.title('Soluci\u00f3n de la EDO usando el m\u00e9todo de Euler')\nplt.legend()\nplt.show()\n\n</code></pre> <pre><code>\n\nEste c\u00f3digo implementa el m\u00e9todo de Runge-Kutta de segundo orden (RK2) para \nresolver una ecuaci\u00f3n diferencial ordinaria (EDO)\n#Gr\u00e1fica RK2\nImportaci\u00f3n de bibliotecas\nimport numpy as np\nimport matplotlib.pyplot as plt\nDefinici\u00f3n de la EDO a resolver\ndef f(x, t):\n    return -x**3 + np.sin(t)\nPar\u00e1metros iniciales, brindados por el enunciado \nt0 = 0\nx0 = 0\ntf = 10\nEsta funci\u00f3n rk2 implementa el m\u00e9todo de Runge-Kutta de segundo orden (RK2).\nPrimero se calcula el n\u00famero de pasos, luego se inicializan los arrays t y \nx con ceros. Se establecen las condiciones iniciales.Se utiliza un bucle \nfor para actualizar los valores de t y x en cada paso, utilizando el m\u00e9todo\nRK2. En cada iteraci\u00f3n se actualizan los valores de k1 y k2. Y con estos \nvalores obtenidos, se encuentran los valores de x y t actualizados. Finalmente, \nse devuelven los arrays t y x con los valores calculados.\ndef rk2(f, t0, x0, tf, h):\n    n_steps = int((tf - t0) / h)\n    t = np.zeros(n_steps + 1)\n    x = np.zeros(n_steps + 1)\n\n    t[0] = t0\n    x[0] = x0\n\n    for n in range(n_steps):\n        k1 = h * f(x[n], t[n])\n        k2 = h * f(x[n] + 0.5 * k1, t[n] + 0.5 * h)\n        x[n + 1] = x[n] + k2\n        t[n + 1] = t[n] + h\n\n    return t, x\n\nSe obtienen los resultados de resolver la EDO utilizando dos tama\u00f1os de paso \ndiferentes: 20 pasos y 1000 pasos.\n\n#20 pasos \nh_20=(tf-t0)/20\nt_20, x_20 = rk2(f, t0, x0, tf, h_20)\n\n#1000 pasos \nh_1000=(tf-t0)/1000\nt_1000, x_1000 = rk2(f, t0, x0, tf, h_1000)\n\nSe crea un gr\u00e1fico para visualizar las soluciones de la EDO obtenidas con 20 \ny 1000 pasos\n\nplt.figure(figsize=(10, 6))\nplt.plot(t_20, x_20, label='20 pasos', marker='o')\nplt.plot(t_1000, x_1000, label='1000 pasos', linestyle='--')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.title('Soluci\u00f3n de la EDO usando el m\u00e9todo RK2')\nplt.legend()\nplt.show()\n</code></pre> <pre><code>\n\n#Gr\u00e1fica RK4\nEste c\u00f3digo implementa el m\u00e9todo de Runge-Kutta de cuarto orden (RK4) para \nresolver una ecuaci\u00f3n diferencial ordinaria (EDO)\n\n\nImportaci\u00f3n de bibliotecas\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nDefinici\u00f3n de la EDO a resolver\ndef f(x, t):\n    return -x**3 + np.sin(t)\n\nPar\u00e1metros iniciales, brindados por el enunciado \nt0 = 0\nx0 = 0\ntf = 10\nEsta funci\u00f3n rk4 implementa el m\u00e9todo de Runge-Kutta de cuarto orden (RK4). \nSe calcula el n\u00famero de pasos. Se inicializan los arrays t y x con cero, \nluego se establecen las condiciones iniciales. Se utiliza un bucle for \npara actualizar los valores de t y x en cada paso utilizando el m\u00e9todo RK4. \nEn cada iteraci\u00f3n se encuentran los valores de k1, k2, k3 y k4, con sus \nrespectivas ecuaciones. Luego con estos valores actualizados se encuentra \nlos valores de x y t. La actualizaci\u00f3n de x si utiliza los k reci\u00e9n encontrados. \nFinalmente, se devuelven los arrays t y x con los valores calculados.\ndef rk4(f, t0, x0, tf, h):\n    n_steps = int((tf - t0) / h)\n    t = np.zeros(n_steps + 1)\n    x = np.zeros(n_steps + 1)\n\n    t[0] = t0\n    x[0] = x0\n\n    for n in range(n_steps):\n        k1 = h * f(x[n], t[n])\n        k2 = h * f(x[n] + 0.5 * k1, t[n] + 0.5 * h)\n        k3 = h * f(x[n] + 0.5 * k2, t[n] + 0.5 * h)\n        k4 = h * f(x[n] + k3, t[n] + h)\n        x[n + 1] = x[n] + (k1 + 2*k2 + 2*k3 + k4) / 6\n        t[n + 1] = t[n] + h\n\n    return t, x\n\nSe resuelve la EDO utilizando dos tama\u00f1os de paso diferentes: 20 pasos y \n1000 pasos. \n#20 pasos\nh_20 = (tf - t0) / 20\nt_20, x_20 = rk4(f, t0, x0, tf, h_20)\n\n# 1000 pasos\nh_1000 = (tf - t0) / 1000\nt_1000, x_1000 = rk4(f, t0, x0, tf, h_1000)\nSe crea un gr\u00e1fico para visualizar las soluciones de la EDO obtenidas con 20 \ny 1000 pasos\nplt.figure(figsize=(10, 6))\nplt.plot(t_20, x_20, label='20 pasos', marker='o')\nplt.plot(t_1000, x_1000, label='1000 pasos', linestyle='--')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.title('Soluci\u00f3n de la EDO usando el m\u00e9todo RK4')\nplt.legend()\nplt.show()\n\nA continuaci\u00f3n se muestran las gr\u00e1ficas de los m\u00e9todos Euler, RK2 y RK4, \nrespectivamente. El objetivo de mostrar ambas curvas, es poder comparar \ny ver que el rendimiento de 1000=h es mucho mejor que cuando se trabaja \nun h=20\n</code></pre>"}]}